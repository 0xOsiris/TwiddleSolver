/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package hw1;

/**
 *
 * @author Leyton
 */

import java.util.*;

public class Solver{
    
    public Set<String> closed = new HashSet<String>();
    public Queue<Node> q = new LinkedList<>();
    
    public Node initialNode;
    public char[] goalState;
    public String strGoal;
    
    public Solver(String initialState, String goalState){
        this.initialNode = new Node(initialState.toCharArray(), null, null);
        this.goalState = goalState.toCharArray();
        this.strGoal = goalState;
        
    }
    
    
    
    String BFS(){
        
        q.add(this.initialNode);
        
        while(!q.isEmpty()){
            Node current = q.remove();
        
            if(String.valueOf(current.boardState).equals(strGoal)){
                return genPreviousMoves(current);

            }else{
                closed.add(String.valueOf(current.boardState));
                List<Node> children=createChildren(current);
                for(Node n:children){
                    if(closed.contains(String.valueOf(n.boardState)))
                        continue;
                    closed.add(String.valueOf(n.boardState));
                    q.add(n);
                        
                    
                }
                
                

            }
        }return null;

    }
    
    //Generates a String[] of previos moves to the node
    String genPreviousMoves(Node n){
        List<Node> parentNodes= new LinkedList();
        parentNodes.add(n);
        while(n.hasParent()){
            parentNodes.add(n.getParent());
            n=n.getParent();
        }
        
        String[] prevMoves = new String[parentNodes.size()];
        //collect the sequence of prev moves 
        for(int i=0; i<parentNodes.size(); i++){
            prevMoves[i]= parentNodes.get(i).prevMove;
        }
        String moveSeq = Arrays.toString(prevMoves);
        String Solution= ("This Board can be solved by"+"\n"+
                moveSeq+":First Move"+"\n"+
                "Considered a total of "+Integer.toString(closed.size())+"\n"+
        
                "Fringe Still contains "+Integer.toString(q.size()));
        
        return Solution;
    }
    
    
    //created ArrayList of Nodes generated by doing all moves on 
    //the rootNode
    private List<Node> createChildren(Node rootNode) {
        List<Node> children = new ArrayList<>();
        children.add(rootNode.rotAc());
        children.add(rootNode.rotAcc());
        children.add(rootNode.rotBc());
        children.add(rootNode.rotBcc());
        children.add(rootNode.rotCc());
        children.add(rootNode.rotCcc());
        children.add(rootNode.rotDc());
        children.add(rootNode.rotDcc());
        
        return children;
        
    }

}


